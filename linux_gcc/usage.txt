  zengl v1.2.1的版本，该版本修复v1.2.0中的函数调用的BUG，v1.2.0中当函数定义在函数调用之后时，函数调用就找不到正确的函数入口地址，该版本通过增加ZL_R_DT_LDFUNID指令操作数类型来解决此BUG，函数调用时会先在指令中存放函数ID，在链接替换时再将函数ID替换为伪地址，最后再将伪地址替换为汇编的真实位置。另外增加一个API接口函数:zenglApi_Stop,用户可以通过此接口在中途停止脚本。最后将所有代码转为unix换行符，以适应github

  作者：zenglong
  时间：2013年8月17日
  官网：www.zengl.com
  
  zengl v1.2.0的版本,该版本已经重写了所有的源代码，采用面向对象方式，将C文件中主要的全局变量和函数(函数以函数指针的形式)写到结构体中。对C文件名，以及源码中变量，宏，结构体等命名方式进行了统一处理，对所有内部错误信息进行统一管理。将zengl转变为类似lua的嵌入式脚本语言，zengl是以动态连接库的形式嵌入到用户的C或C++程序中,取消原来的.zlc后缀的汇编指令文件，直接编译执行.zl脚本，编译器和解释器都整合在zengl动态链接库中。

  zengl中主要的源码文件如下：

  zengl_locals.c 国际化语言文件，将虚拟机内部所有可能的出错信息，以及关键字的字符串信息，汇编指令的输出符号信息等都定义在该文件的不同数组中。可以定义自己的出错信息以及该出错信息对应的宏，在编译zengl生成动态链接库时，通过定义ZL_LANG_EN_WITH_CH宏，可以让zengl输出默认的中英文混合出错信息。如果需要定义其他语言的出错信息，可以在该文件中自定义一个ZL_LANG_....之类的宏，再自己写一个ZL_Error_String数组，最后在编译zengl时，指定ZL_LANG_....宏即可。

  zengl_main.c zengl编译器的主体程式，里面定义了和编译器相关的函数，主要是词法扫描相关的函数，当然也包括一些编译器和虚拟机的初始化函数等。

  zengl_parser.c 该文件中定义了一些和语法解析相关的函数。语法解析生成AST抽象语法树的过程主要集中在zengl_express函数中，该函数采用第三个版本的语法解析引擎，对以前版本的算法进行了调整，采用纯状态机加优先级堆栈的方式，比第二个版本的可读性强很多，语法错误的定位也更准确，方便维护和扩展。

  zengl_symbol.c 该文件定义了和符号表相关的函数，全局变量，函数，类等符号信息都是通过该文件中的函数来生成。

  zengl_assemble.c 该文件定义了和汇编指令输出相关的函数，汇编指令不再像以前的版本那样输出到.zlc文件中，而是直接输出到虚拟机解释器的指令动态数组中，这样汇编链接结束后，解释器就可以马上执行。

  zengl_ld.c 该文件定义了和链接器相关的函数，主要是对JMP等指令中的跳转地址进行解析，将汇编中的伪跳转地址转为真实的汇编指令位置。

  zenglrun_main.c 该文件定义了和虚拟机的解释器相关的函数，解释器通过这些函数来解释执行汇编指令。

  zenglrun_func.c 该文件定义了和解释器相关的辅助函数，如解释器中内存池的操作函数等。

  zenglApi.c 该文件定义了zengl虚拟机对外提供的接口函数(即zengl动态链接库对外的导出函数)，用户通过这些接口函数就可以在自己的C程序及C++程序中加载执行zengl脚本，并为zengl脚本自定义一些模块函数等。

  zengl_exportfuns.h 该头文件中主要是对zengl动态链接库导出函数进行声明，要在自己的程序中使用zengl，就必须包含该头文件，并且在包含该头文件前，定义操作系统宏，例如windows环境下，需要#define ZL_EXP_OS_IN_WINDOWS宏，然后再包含该头文件，当然也可以在VS之类的IDE的项目配置中定义，或者makefile中定义，这些地方定义了就不需要在源码中再定义了，如果没有这个宏，那么编译就会出错，因为这个宏决定了导出函数是以windows的dll方式导出，还是以Linux的so方式导出。对于Linux系统，可以定义ZL_EXP_OS_IN_LINUX宏，也可以不定义，因为zengl默认就是使用Linux模式。

  zengl_exportPublicDefs.h 该头文件会由zengl_exportfuns.h自动包含进来，里面定义了一些宏和结构体，用户在使用zengl导出的接口时，可能会用到这些宏和结构体，通过阅读该文件，可以知道为什么在windows系统下，一定要定义ZL_EXP_ON_IN_WINDOWS宏的原因。另外该文件中还包含了zengl主次版本号等信息(这些信息以宏的形式存在)。

  zengl_global.h 该头文件是zengl内部的核心头文件，所有虚拟机，编译器，解释器等相关的宏和结构体，以及上面提到过的C源码中需要使用的宏，枚举值，结构体等，都定义在该头文件中。

  zengl_locals.h 该头文件定义了zengl_locals.c中出错信息对应的宏等。

  以上就是zengl动态链接库生成时所需的核心源码文件。

  另外，需要注意的是，main.c并不是zengl的核心文件，它只是用来测试zengl嵌入式开发的测试程序，里面有zengl加载方法，API接口的使用示例等，用户可以参照这个文件来使用zengl进行嵌入式脚本开发，对于C++的用户在定义自己的模块函数时，请将这些模块函数使用extern "C"括起来。

  由于zengl已经转为嵌入式编程语言，所以之前的SDL之类的模块都没包含进来，作者只想保留最核心的编译解析部分，其他的模块函数请在用户自己的程序中完成(包括array这样的函数，用户也必须自己定义，可以参照main.c中的代码，注意: print属于保留关键字，不属于模块函数)。

  增加了类函数，用法可以参考test.zl脚本 
    
  作者：zenglong
  时间：2013年8月14日
  官网：www.zengl.com

先运行make clean 将原来生成的libzengl.so main.o和zengl删除

再运行make

生成libzengl.so main.o 和 zengl

接着运行./zengl test.zl即可测试main.c程序(该程序是测试zengl用的，在这里生成的zengl核心文件只有libzengl.so动态链接库)
